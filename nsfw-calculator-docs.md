# NSFW Score Calculator v0.1 — техническая документация

## Назначение

Веб-калькулятор для оценки степени NSFW-контента на изображении. Принимает изображение, отправляет его в Vision-модель через OpenRouter API, получает четыре числовые оценки и вычисляет итоговый балл по формуле noisy-OR.

---

## Входные параметры

| Параметр | Диапазон | Смысл |
|---|---|---|
| **N** (Nudity) | 0–10 | Взвешенная сумма открытых зон тела по 12 анатомическим областям |
| **pfg** (Framing) | 0–10 | `max(p, f, g)` — сексуальность позы, ракурса камеры, мимики |
| **D** (Design) | 0–10 | Сумма маркеров сексуализации костюма/атрибутики (обрезается до 10) |
| **A** (Actions) | 0–10 | Дискретная шкала явности сексуальных действий |

Весовые коэффициенты `wn / wf / wd` (по умолчанию `0.9 / 0.6 / 0.6`) ограничивают максимальный вклад каждого слагаемого в Presentation. Редактирование коэффициентов блокируется чекбоксом «Зафиксировать коэффициенты» (по умолчанию включён); при снятии флага поля `wn`, `wf`, `wd` становятся доступны для ввода.

---

## Формулы

Все четыре параметра нормализуются `÷ 10` перед подстановкой.

**Presentation** — промежуточная оценка визуального контекста:

```
P = 1 − (1 − wn·N) · (1 − wf·pfg) · (1 − wd·D)
```

**Score** — итоговый балл, объединяющий действия и контекст:

```
S = 1 − (1 − A) · (1 − P)
```

Результат `S` умножается на 10 для отображения в диапазоне 0–10.

Обе формулы реализуют **noisy-OR**: если хотя бы один из факторов максимален, итог стремится к максимуму. Факторы взаимно усиливают друг друга, а не просто складываются, что предотвращает выход за границу диапазона.

---

## Архитектура кода

Приложение — однофайловый HTML без фреймворков. Логически делится на четыре слоя.

### 1. UI / разметка

Три смысловых секции:
- **Блок загрузки изображения** — drop-зона с превью, статус-строка, прогресс-бар.
- **Итоговая панель** — крупное число, градиентная полоса, переходящая из янтарного в красный по мере роста оценки.
- **Формульные секции** — `Presentation` и `Score`: поля ввода прямо в тексте формулы, inline-результаты.

Легенда, блоки ключа и футера — вспомогательные.

### 2. Вычислительное ядро

```js
function calc()
```

Читает все поля через `val(id, max)` (зажимает в `[0, max]`, возвращает 0 при NaN), вычисляет P и S, обновляет DOM. Вызывается на каждый `input`-событие.

```js
function sanitize(e)
```

Фильтрует нечисловые символы прямо при вводе, не даёт пройти второй точке.

При загрузке страницы (`DOMContentLoaded`) поля данных сбрасываются в `0`, коэффициентам выставляются дефолтные значения, после чего вызывается `calc()`.

### 3. Слой работы с API

```
Пользователь → drop / paste / click
  → processFile(file)
      └─ resizeIfNeeded(file)         // масштабирование на canvas
           └─ analyzeImage(key, base64, mediaType)   // fetch → OpenRouter
                └─ applyScores({ N, pfg, D, A })
                     └─ calc()
```

**Источники изображения** — три независимых обработчика:
- `drop` на drop-зоне,
- `change` на скрытом `<input type="file">` (открывается по клику на зону),
- `paste` на `document` — перехватывает вставку изображения из буфера обмена через `clipboardData.items`.

**`resizeIfNeeded(file)`** — подготовка изображения перед отправкой. Если меньшая сторона менее 1200 px или большая сторона более 1568 px, изображение масштабируется: вычисляется коэффициент `1568 / max(w, h)`, рисуется на `canvas` и конвертируется в JPEG с качеством 0.92. Иначе файл читается как есть. Возвращает `{ base64, mediaType, width, height }`.

**`analyzeImage(key, base64, mediaType)`** формирует запрос к `openrouter.ai/api/v1/chat/completions`:
- Модель: `anthropic/claude-opus-4.6` через провайдера `google-vertex` без fallback.
- `temperature: 0`, `seed: 42` — детерминированный вывод.
- Заголовки `HTTP-Referer` и `X-Title` зависят от origin: для `mariskori.github.io` title будет `NSFW calculator`, для прочих http-хостов — `NSFL calculator`, для локального файла — `Local-host`.
- System prompt содержит полную разметочную инструкцию с описанием шкал и формата ответа.
- Модель обязана вернуть чистый JSON с полями `N`, `pfg`, `D`, `A`, `name`, `N_arr`, `pfg_arr`.

После получения ответа функция:
1. Стрипает возможные markdown-обёртки (` ```json ``` `).
2. Проверяет наличие обязательных числовых полей.
3. Обрабатывает отказ модели как крайний случай: если в ответе есть подстрока `I'm sorry, but` или `I'm not able to provide` — выставляет `A: 10` как сигнал «слишком горячая».

**Подсчёт стоимости.** Объект `PRICE` хранит цены за 1M токенов для каждой модели (для `claude-opus-4.6`: input — $5, output — $25). После успешного анализа вычисляется стоимость запроса и отображается зелёным рядом с именем модели.

### 4. Состояние и хранилище

Состояние полностью в DOM. Единственный `localStorage`-ключ — `keyNSFW` (API-ключ пользователя), загружается при старте через `loadKey()`. Глобальная переменная `GLOBAL_TEXT` — последний сырой ответ модели для отладки в консоли.

---

## Прогресс-бар

Реализован как **fake progress**: не отражает реальный прогресс запроса, а имитирует его двумя фазами CSS-перехода.

- Фаза 1: `0% → 80%` за 5 с, `transition: linear`.
- Фаза 2: `80% → 98%` за 5 с, `transition: ease-out` (замедление — симуляция ожидания ответа).
- По завершении запроса: мгновенный доезд до `100%`, затем скрытие.

Таймер хранится в `fakeProgressTimer` и очищается при ошибке (`resetFakeProgress`) или успехе (`finishFakeProgress`). Перед каждым новым запуском бар сбрасывается через `void bar.offsetWidth` (принудительный reflow), чтобы transition не применился к сбросу.

---

## Полный поток данных

```
Пользователь (drop / paste / click)
  → processFile(file)
      → превью в drop-зоне
      → resizeIfNeeded → { base64, mediaType, width, height }
          → analyzeImage → fetch OpenRouter (Vision-модель)
              → JSON { N, pfg, D, A, name, ... }
                  → applyScores → DOM-поля
                      → calc()
                          → P, S → DOM (presOut, scoreOut, scoreBar, цвет полосы)
                          → стоимость → analyzeModel
```
